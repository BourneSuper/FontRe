<?php
	//主控制器，框架的主入口，获取类名和方法名，实现反射调用，管理SqlHelper
    
    //获取参数
    if(empty($_REQUEST['cotrollerName']) && empty($_REQUEST['cotrollerMethod']) ){
       die("<br/>请先传入cotrollerName，cotrollerMethod"); 
    }
    $controllerName = $_REQUEST['cotrollerName'];//alias
    $controllerMethod = $_REQUEST['cotrollerMethod'];

  
    //1.普通类由 类加载器自动加载
    require_once 'src/Core/PSR4AutoLoader.php';
    $loader = new BourneSuper\FrontRe\Core\PSR4AutoLoader;
    $loader->register();
    $loader->addNamespace('BourneSuper\FrontRe', './src');
    
    //2.加载次级控制器
    $controllerName = loadSecondaryControllers('BourneSuper\FrontRe', $controllerName);
    
    
    
    //3.反射创建类并调用其方法
    $controller = new $controllerName();        
   
    $res = $controller->$controllerMethod();
    
    //4.释放sqlHelper
    unset( $_SESSION['sqlHelper'] );
    
    
//------------------------------- functions --------------------------------------    
    
    /**
     * fn 加载次级控制器
     * @param string $prefix
     * @param string $controllerAlias
     * @return string|boolean
     */
    function loadSecondaryControllers( $prefix, $controllerAlias ){
        
    	$arr = scanSecondaryControllers();
    	
    	foreach( $arr as $key => $value ){
    		if( $controllerAlias == $key && strpos( $value, "mainController.php" ) === false ){
    			require_once $value;
    			return $prefix . parse2ControllerName($value);
    		}
    		
    	}
    	
    	return false;

    }
    
    /**
     * fn返回控制器的带有路径的文件名的数组，['alias'=>'dirName1/.../dirNameN/fileName' , 'alias2'=>'.../fileName2'...]
     * 
     * @return array, an array of file name of controller
     */
    function scanSecondaryControllers(){
        $arr = array();
        if( file_exists('secondaryControllerMap.php') ){
            $arr = require_once 'secondaryControllerMap.php';
        }else{
        	//
        	$fileArr = [];
        	recursionFindFile( '.', $fileArr );
        	
        	foreach( $fileArr as $value ){
        		if( strpos($value, "Controller.php") !== false ){
        			$lastSlopePosition = strrpos($value, '/');
        			$contollerName = substr($value, $lastSlopePosition + 1, -4);
        			$arr[$contollerName] = $value;
				}
        	}
        	
        	//
        	$secondaryControllerMapStr = "<?php" . PHP_EOL;
        	$secondaryControllerMapStr .= "//@generated by mainController.php" . PHP_EOL;
        	$secondaryControllerMapStr .= "return" . PHP_EOL;
        	$secondaryControllerMapStr .= var_export($arr, true) . ';'; 
            
        	file_put_contents('secondaryControllerMap.php', $secondaryControllerMapStr);
        	
        }
        
        return $arr;
        
    }
    
    /**
     *fn 递归读取目录,返回带有路径的文件名
     * @param $dirPath 目录
     * @param array $resArr, 取引用
     *@return an array of file name with path
     */
    function recursionFindFile( $dirPath, &$resArr){
        $resDir = opendir( $dirPath );
        while( $baseName = readdir($resDir) ){
            //当前文件路径
            $path = $dirPath . '/' . $baseName;
            if(is_dir($path) && $baseName!='.' && $baseName!='..'){
            	recursionFindFile( $path, $resArr );
            }else if(basename($path)!='.' AND basename($path)!='..'){
            	$resArr[] = $path;
            }
            
        }
        closedir($resDir);
        
    }
    
    /**
     * fn 将带有路径的文件名格式化为别名（不含命名空间的类）
     * @param string $filePath
     * @return string
     */
    function parse2ControllerAlias($filePath){
    	$lastSlopePosition = strrpos($filePath, '/');
    	$contollerName = substr($filePath, $lastSlopePosition + 1, -4);
    	
    	return $contollerName;
    }
    
    /**
     * fn 将带有路径的文件名格式化为类名
     * @param string $filePath
     * @return mixed
     */
    function parse2ControllerName($filePath){
    	$position = strpos($filePath, 'src/');
    	$contollerName = str_replace( "/", "\\", substr($filePath, $position + 3, -4) ); 
    	
    	return $contollerName;
    }
    
    
    
    
    
    
    
?>





